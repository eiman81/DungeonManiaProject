blog 1: We planned for and implemented 1A and completed it. Planning part was okay as we had some idea on how to go about this task but it was a difficult task to implement and also confusing but we figured the problem. It was particularly confusing putting the move body in a class so that it would work for all the enemies. Furthermore, we completed question 1B. It wasn't too difficult to find observer pattern as there was a UML diagram given. Through looking at the diagram we could find the pattern and wrote an example as the answer. We also completed 1C. 1C took a little bit of time to figure out but was not difficult when the inheritance code smell was found. It was as simple as removing abstract from the method definitions in entity class. Subsequently, deleting methods in subclasses that didn't override.

blog 2: We implemented d of task1. It was tricky to figure out at first as the question was quite confusing. However, we found the solution where the code smell was a shotgun pattern, one change requires many small changes in other classes. Hence, for collectable items, we decided to make a superclass with the common methods "onOverlap" and "canMoveOnto" so that one change doesn't require the engineer to go through each of the item classes and change manually. Furthermore, we implemented the open-close goal question. This question was also quite tricky as we had to create many different classes for each type of goal and move some common methods into other classes etc. It took quite a long time to figure as the previous design was not of good quality and too complex and violated DRY in many cases. Thus, we utilised strategy pattern to separate some functionalities.

blog 3: We implemented task 1 f open refactoring today. We modified the playerState to use enums instead of boolean variables to represent the playerâ€™s state. This is a more efficient approach to represent discrete states and also later we can add more states easier by just modifying the enum file. Additionally, the different state files implement the same duplicated transitions, we can turn this into a switch statement in PlayerState. Furthermore, we added factory classes for all the entities and had a class "entityFactory" to call the type of entity and produce an object of its type. We also refactored entityfactory buildbow and buildshield to fix its hardcoding and moved checking available positions in entityfactory.spawnspider to map as it is more suited in map. We also had a few minor refactoring such as removing DRY and lsp and lod.
